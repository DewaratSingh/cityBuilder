<html>

<head>
  <title>City Builder</title>
  <link rel="stylesheet" href="style.css" />
</head>

<body>
  <canvas id="canvas"></canvas>
  <div id="time"></div>
  <div id="selector">
    <div id="option">
      <div onmousedown="event.stopPropagation()" onclick="tabChange(event,this)">
        Move
      </div>
      <div onmousedown="event.stopPropagation()" onclick="tabChange(event,this)">
        Road
      </div>
      <div onmousedown="event.stopPropagation()" onclick="tabChange(event,this)">
        Zone
      </div>
      <div onmousedown="event.stopPropagation()" onclick="tabChange(event,this)">
        Trees
      </div>
      <div onmousedown="event.stopPropagation()" onclick="tabChange(event,this)">
        Building
      </div>
    </div>
    <div id="obj" class="your-div"></div>
  </div>
  <div id="constructionline"></div>

  <script src="./nessary/uitask.js"></script>
  <script src="./nessary/Camera.js"></script>
  <script src="./map/chunck.js"></script>
  <script src="./map/contry.js"></script>
  <script src="./nessary/vector.js"></script>
  <script src="./nessary/util.js"></script>
  <script src="./road/Circle.js"></script>
  <script src="./road/segment.js"></script>
  <script src="./road/zone.js"></script>
  <script src="./road/road.js"></script>
  <script src="./assertCode/house.js"></script>
  <script src="./assertCode/build.js"></script>
  <script src="./assertCode/building.js"></script>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Handle window resize and orientation changes
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });

    window.road = new Road();

    window.building = new Building();

    Time = Date.now();
    let lastReal = Date.now();
    timespeed = 1_000_000;
    let lastAreaSearchTime = Time;
    const DAY_MS = 24 * 60 * 60 * 1000;
    const TWO_MONTHS_MS = 60 * DAY_MS;

    setInterval(() => {
      const now = Date.now();
      let realDelta = now - lastReal;
      lastReal = now;

      realDelta = Math.min(realDelta, 100);

      Time += realDelta * timespeed;

      document.getElementById("time").innerHTML = new Date(
        Time
      ).toLocaleDateString("en-IN");

      if (Time - lastAreaSearchTime >= TWO_MONTHS_MS) {
        window.building.searchForArea();
        lastAreaSearchTime = Time;
      }
    }, 100);

    let camera = new Camera(canvas);
    window.camera = camera

    let zone = { start: { x: 0, y: 0 }, move: { x: 0, y: 0 }, down: false };

    let FPS = 0;
    setInterval(() => {
      FPS = 0;
    }, 1000);

    let contry = new Country(64, 64, ctx);
    window.contry = contry

    function animation() {
      FPS++;
      camera.restore(ctx);
      camera.setZoom();
      contry.draw(ctx);
      window.road.draw(ctx, camera.mouse.move, zone);
      window.building.draw(ctx, camera.mouse.move);


      AreaZone.drawZone(zone);

      requestAnimationFrame(animation);
    }
    animation();

    document.addEventListener("mousedown", (e) => {
      camera.mouse.down = camera.getMousePosition(e);
      switch (Tab) {
        case "Move":
          camera.mouse.drag = true;
          camera.mouse.down.is = true;
          break;
        case "Road":
          if (e.button == 1) {
            camera.mouse.drag = true;
          }
          if (e.button == 0) {
            window.road.createStartSegment(camera.getMousePosition(e));
            camera.mouse.down.is = true;
          }
          if (e.button == 2) {
            window.road.deleteSegmentAt(camera.getMousePosition(e));
          }
          break;
        case "Zone":
          zone.start = camera.getMousePosition(e);
          zone.move = camera.getMousePosition(e);
          zone.down = true;
          break;
        case "Building":
          window.building.placeBuilding();
          break;
        case "Trees":
          window.building.placeBuilding();
          break;
      }
    });

    document.addEventListener("mousemove", (e) => {
      camera.mouse.move = camera.getMousePosition(e);
      switch (Tab) {
        case "Move":
          if (camera.mouse.drag) {
            camera.mouse.offset = {
              x: camera.mouse.move.x - camera.mouse.down.x,
              y: camera.mouse.move.y - camera.mouse.down.y,
            };
            camera.Offset = {
              x: camera.Offset.x + camera.mouse.offset.x,
              y: camera.Offset.y + camera.mouse.offset.y,
            };
          }
          break;
        case "Road":
          if (camera.mouse.down.is) {
            window.road.createEndSegmentMove(camera.getMousePosition(e));
          }
          if (camera.mouse.drag) {
            camera.mouse.offset = {
              x: camera.mouse.move.x - camera.mouse.down.x,
              y: camera.mouse.move.y - camera.mouse.down.y,
            };
          }
          break;
        case "Zone":
          if (zone.down) {
            zone.move = camera.getMousePosition(e);
          }
          break;
      }
    });

    document.addEventListener("mouseup", (e) => {
      switch (Tab) {
        case "Move":
          camera.mouse.down.is = false;
          if (camera.mouse.drag) {
            camera.Offset = {
              x: camera.Offset.x + camera.mouse.offset.x,
              y: camera.Offset.y + camera.mouse.offset.y,
            };
            let zoom = camera.mouse.zoom;
            camera.mouse = {
              down: { x: 0, y: 0, is: false },
              move: { x: 0, y: 0 },
              up: { x: 0, y: 0 },
              zoom: zoom,
              drag: false,
              offset: { x: 0, y: 0 },
            };
          }
          break;
        case "Road":
          if (camera.mouse.down.is) {
            window.road.createEndSegment(camera.getMousePosition(e));
            camera.mouse.down.is = false;
          }
          if (camera.mouse.drag) {
            camera.Offset = {
              x: camera.Offset.x + camera.mouse.offset.x,
              y: camera.Offset.y + camera.mouse.offset.y,
            };
            let zoom = camera.mouse.zoom;
            camera.mouse = {
              down: { x: 0, y: 0, is: false },
              move: { x: 0, y: 0 },
              up: { x: 0, y: 0 },
              zoom: zoom,
              drag: false,
              offset: { x: 0, y: 0 },
            };
          }
          break;
        case "Zone":
          zone = { start: { x: 0, y: 0 }, move: { x: 0, y: 0 }, down: false };
          break;
      }
    });
    document.addEventListener("mousewheel", (e) => {
      camera.zoom(e);
    });

    // Mobile touch controls
    let touches = {
      one: null,
      two: null,
      initialDistance: 0,
      initialZoom: 1,
      initialOffset: { x: 0, y: 0 },
      initialMidpoint: { x: 0, y: 0 },
      twoFingerGesture: false
    };

    function getTouchPos(touch) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: touch.clientX - rect.left,
        y: touch.clientY - rect.top
      };
    }

    function getDistance(touch1, touch2) {
      const dx = touch2.x - touch1.x;
      const dy = touch2.y - touch1.y;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function getMidpoint(touch1, touch2) {
      return {
        x: (touch1.x + touch2.x) / 2,
        y: (touch1.y + touch2.y) / 2
      };
    }

    canvas.addEventListener("touchstart", (e) => {
      e.preventDefault();

      if (e.touches.length === 1) {
        // Single touch - treat like mouse down for current tab
        touches.one = getTouchPos(e.touches[0]);
        camera.mouse.down = camera.getMousePosition({
          clientX: e.touches[0].clientX,
          clientY: e.touches[0].clientY
        });

        switch (Tab) {
          case "Move":
            camera.mouse.drag = true;
            camera.mouse.down.is = true;
            break;
          case "Road":
            window.road.createStartSegment(camera.mouse.down);
            camera.mouse.down.is = true;
            break;
          case "Zone":
            zone.start = camera.mouse.down;
            zone.move = camera.mouse.down;
            zone.down = true;
            break;
          case "Building":
          case "Trees":
            window.building.placeBuilding();
            break;
        }
      } else if (e.touches.length === 2) {
        // Two fingers - pan and zoom mode
        touches.twoFingerGesture = true;
        touches.one = getTouchPos(e.touches[0]);
        touches.two = getTouchPos(e.touches[1]);
        touches.initialDistance = getDistance(touches.one, touches.two);
        touches.initialZoom = camera.mouse.zoom;
        touches.initialOffset = { ...camera.Offset };
        touches.initialMidpoint = getMidpoint(touches.one, touches.two);

        // Cancel any ongoing road creation
        if (Tab === "Road" && camera.mouse.down.is) {
          camera.mouse.down.is = false;
        }
      }
    });

    canvas.addEventListener("touchmove", (e) => {
      e.preventDefault();

      if (e.touches.length === 1 && touches.one) {
        // Single touch move
        const currentTouch = getTouchPos(e.touches[0]);
        camera.mouse.move = camera.getMousePosition({
          clientX: e.touches[0].clientX,
          clientY: e.touches[0].clientY
        });

        switch (Tab) {
          case "Move":
            if (camera.mouse.drag) {
              camera.mouse.offset = {
                x: camera.mouse.move.x - camera.mouse.down.x,
                y: camera.mouse.move.y - camera.mouse.down.y,
              };
              camera.Offset = {
                x: camera.Offset.x + camera.mouse.offset.x,
                y: camera.Offset.y + camera.mouse.offset.y,
              };
            }
            break;
          case "Road":
            if (camera.mouse.down.is) {
              window.road.createEndSegmentMove(camera.mouse.move);
            }
            break;
          case "Zone":
            if (zone.down) {
              zone.move = camera.mouse.move;
            }
            break;
        }
      } else if (e.touches.length === 2) {
        // Two finger move - pan and zoom
        const touch1 = getTouchPos(e.touches[0]);
        const touch2 = getTouchPos(e.touches[1]);
        const currentDistance = getDistance(touch1, touch2);
        const currentMidpoint = getMidpoint(touch1, touch2);

        // Calculate zoom based on pinch distance
        if (touches.initialDistance > 0) {
          const zoomFactor = touches.initialDistance / currentDistance;
          const newZoom = touches.initialZoom * zoomFactor;

          // Clamp zoom between reasonable values (0.1 to 10)
          camera.mouse.zoom = Math.max(0.1, Math.min(10, newZoom));
        }

        // Calculate pan based on midpoint movement
        const panDeltaX = currentMidpoint.x - touches.initialMidpoint.x;
        const panDeltaY = currentMidpoint.y - touches.initialMidpoint.y;

        camera.Offset = {
          x: touches.initialOffset.x + panDeltaX,
          y: touches.initialOffset.y + panDeltaY
        };
      }
    });

    canvas.addEventListener("touchend", (e) => {
      e.preventDefault();

      if (e.touches.length === 0) {
        // All touches ended
        switch (Tab) {
          case "Move":
            camera.mouse.down.is = false;
            if (camera.mouse.drag) {
              let zoom = camera.mouse.zoom;
              camera.mouse = {
                down: { x: 0, y: 0, is: false },
                move: { x: 0, y: 0 },
                up: { x: 0, y: 0 },
                zoom: zoom,
                drag: false,
                offset: { x: 0, y: 0 },
              };
            }
            break;
          case "Road":
            if (camera.mouse.down.is && !touches.twoFingerGesture) {
              window.road.createEndSegment(camera.mouse.move);
              camera.mouse.down.is = false;
            } else if (touches.twoFingerGesture) {
              // Two finger gesture was used, cancel road creation
              camera.mouse.down.is = false;
            }
            break;
          case "Zone":
            zone = { start: { x: 0, y: 0 }, move: { x: 0, y: 0 }, down: false };
            break;
        }

        // Reset touch tracking
        touches = {
          one: null,
          two: null,
          initialDistance: 0,
          initialZoom: 1,
          initialOffset: { x: 0, y: 0 },
          initialMidpoint: { x: 0, y: 0 },
          twoFingerGesture: false
        };
      } else if (e.touches.length === 1) {
        // One finger remains, reset to single touch mode
        touches.one = getTouchPos(e.touches[0]);
        touches.two = null;
        touches.initialDistance = 0;
      }
    });

    canvas.addEventListener("touchcancel", (e) => {
      e.preventDefault();
      // Reset everything on touch cancel
      touches = {
        one: null,
        two: null,
        initialDistance: 0,
        initialZoom: 1,
        initialOffset: { x: 0, y: 0 },
        initialMidpoint: { x: 0, y: 0 },
        twoFingerGesture: false
      };
      camera.mouse.drag = false;
      camera.mouse.down.is = false;
      zone.down = false;
    });

    window.addEventListener("keydown", (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "q") {
        e.preventDefault();
        if (window.road) {
          window.road.saveToLocalStorage();
          console.log("Road saved to localStorage");
          alert("Saved");
        }
      }
    });

    canvas.addEventListener("contextmenu", (e) => e.preventDefault());
  </script>
</body>

</html>